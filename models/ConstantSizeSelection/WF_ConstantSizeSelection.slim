
function (void) geneConversion(o<Individual> sourceIndividual, integer mean_tracklength)
{

	// Choose an other haploid individual at random
    // different than the source one
	targetIndividual = sourceIndividual;
	while (targetIndividual == sourceIndividual)
	{
		targetIndividual = sample(p1.individuals, 1);
	}

	sourceGenome = sourceIndividual.genomes[0];
	targetGenome = targetIndividual.genomes[0];

	// Choose a track length and a position for the gene conversion event
	position = rdunif(1, 0, sim.chromosome.lastPosition);
	trackLength = asInteger(ceil(rexp(1, mean_tracklength)));
	p_end = (position + trackLength - 1) % sim.chromosome.lastPosition;

	source_m1_muts = sourceGenome.mutationsOfType(m1);
	source_m1_positions = source_m1_muts.position;
	target_m1_muts = targetGenome.mutationsOfType(m1);
	target_m1_positions = target_m1_muts.position;

	// Get the mutations from the sourceGenome and targetGenome that are within the GC track
	// If p_end < position, it means that we're over the edge of the chr
	if (p_end < position)
	{
		mutToCopy = source_m1_muts[source_m1_positions <= p_end | source_m1_positions >= position];
		mutToRemove = target_m1_muts[target_m1_positions <= p_end | target_m1_positions >= position];
	}
    // Else it's normal
	else
	{
		mutToCopy = source_m1_muts[source_m1_positions >= position & source_m1_positions <= p_end];
		mutToRemove = target_m1_muts[target_m1_positions >= position & target_m1_positions <= p_end];
	}

	// Remove the mutations from targetGenome tha are within the track
	targetGenome.removeMutations(mutToRemove);

	// Add the mutations found in sourceGenome
	targetGenome.addMutations(mutToCopy);
    
    return;
}

initialize() {
    initializeMutationRate(1.53e-09);
    initializeMutationType("m1", 1.0, "f", 0.0);
    
    initializeGenomicElementType("g1", m1, 1.0);
    initializeGenomicElement(g1, 0, 2000000);
    initializeRecombinationRate(0);
}
1 late() {
    // save this run's identifier, used to save and restore
    defineConstant("simID", getSeed());
    sim.setValue("freq_end", "None");
    sim.setValue("GC", 0);
    sim.setValue("nindiv", 0);
    sim.setValue("GCrate", 1.53e-09 * 2000000);




    sim.addSubpop("p1", 140000); // 1000 - 300000
    p1.setCloningRate(1.0);

    // READ MS FORMAT INITIAL STATE
    lines = readFile("Results_neutral_1/Haploid_simu_001_000.msin");
    index = 0;

    // skip lines until reaching the // line, then skip that line
    while (lines[index] != "//")
        index = index + 1;
        index = index + 1;

    if (index + 2 + p1.individualCount > size(lines))
        stop("File is too short; terminating.");

    // next line should be segsites:
    segsitesLine = lines[index];
    index = index + 1;
    parts = strsplit(segsitesLine);
    if (size(parts) != 2) stop("Malformed segsites.");
    if (parts[0] != "segsites:") stop("Missing segsites.");
    segsites = asInteger(parts[1]);

    // and next is positions:
    positionsLine = lines[index];
    index = index + 1;
    parts = strsplit(positionsLine);
    // If trailing space at the end of the positions array (as outputed by ms)
    if (size(parts) == segsites + 2)
	{
		parts = parts[0:segsites];
	}
    if (size(parts) != segsites + 1) stop("Malformed positions.");
    if (parts[0] != "positions:") stop("Missing positions.");
    positions = asFloat(parts[1:(size(parts)-1)]);

    // create all mutations in a genome in a dummy subpopulation
    sim.addSubpop("p2", 1);
    g = p2.genomes[0];
    L = sim.chromosome.lastPosition;
    intPositions = asInteger(round(positions * L));
    muts = sapply(intPositions, "g.addNewMutation(m1, 0.0, applyValue);");

    // add the appropriate mutations to each first genome (haploid)
    allGenomes = p1.individuals.genomes;
    haploidGenomes = allGenomes[seqAlong(allGenomes) % 2 == 0];
    for (hg in haploidGenomes)
    {
        f = asLogical(asInteger(strsplit(lines[index], "")));
        index = index + 1;
        hg.addMutations(muts[f]);
    }

    // remove the dummy subpopulation
    p2.setSubpopulationSize(0);

    // (optional) set the generation to match the save point
    // sim.generation = 20000;
}


// Remove mutation on the 2nd chromosome
modifyChild() {
	childGenome2.removeMutations(childGenome2.mutations);
	return T;
}


late() {
    // Remove fixed mutation
    // (Slim does it automatically for diploid,
    // but for haploid, mutations are fixed at 0.5)
    muts = sim.mutationsOfType(m1);
    freqs = sim.mutationFrequencies(NULL, muts);
    sim.subpopulations.genomes.removeMutations(muts[freqs == 0.5], T);

	// Gene Conversion event
	// each individual has a proba of gene conversion per bp
	nindiv = rpois(1, size(p1.individuals) * sim.getValue("GCrate"));
    sim.setValue("nindiv", sim.getValue("nindiv")+nindiv);
    GCSample = sample(p1.individuals, nindiv, replace = T);
	for (i in GCSample)
	{
		sim.setValue("GC", sim.getValue("GC")+1);
		geneConversion(i, 122000);
	}

    if (sim.generation % 109 == 0)
    {
        catn("> " + sim.generation + " : " + size(sim.mutationsOfType(m1)));
    }
}

        
//~ 60 ans
21900 late()
{
    
    //output only genome with mutations
    allGenomes = p1.individuals.genomes;
    haploidGenomes = allGenomes[seqAlong(allGenomes) % 2 == 0];
    haploidGenomesSample = sample(haploidGenomes, 600);
    haploidGenomesSample.outputMS(filePath='Results_neutral_1/Haploid_simu_001_000.msout');
    catn("GC:  " + sim.getValue("GC"));
    catn("mean indiv with GC:  " + sim.getValue("nindiv")/sim.generation);
    sim.simulationFinished();
}
        